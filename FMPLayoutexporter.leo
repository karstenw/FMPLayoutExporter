<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="karstenw.20250707223951.2" a="E"><vh>Application</vh>
<v t="karstenw.20250707224004.1"><vh>@clean FMPLayoutexporter.py</vh>
<v t="karstenw.20250707224051.1"><vh>Declarations</vh></v>
<v t="karstenw.20250707224051.2"><vh>class OutlineWindowController</vh>
<v t="karstenw.20250707224051.3"><vh>__new__</vh></v>
<v t="karstenw.20250707224051.4"><vh>initWithObject_</vh></v>
<v t="karstenw.20250707224051.5"><vh>windowWillClose_</vh></v>
<v t="karstenw.20250707224051.6"><vh>setWindowTitleForObject_</vh></v>
<v t="karstenw.20250707224051.7"><vh>setObject_</vh></v>
<v t="karstenw.20250707224051.8"><vh>export_</vh></v>
</v>
<v t="karstenw.20250707224052.1"><vh>class PythonBrowserAppDelegate</vh>
<v t="karstenw.20250707224052.2"><vh>applicationDidFinishLaunching_</vh></v>
<v t="karstenw.20250707224052.3"><vh>newBrowser_</vh></v>
<v t="karstenw.20250707224052.4"><vh>outlineViewSelectionDidChange_</vh></v>
</v>
<v t="karstenw.20250707224052.5"><vh>getFolderDialog</vh></v>
<v t="karstenw.20250707224152.1"><vh>+ FILEMAKER +</vh>
<v t="karstenw.20250707224052.6"><vh>get_filemaker</vh></v>
<v t="karstenw.20250707224052.7"><vh>get_fmp_docs</vh></v>
<v t="karstenw.20250707224052.8"><vh>getFMPData</vh></v>
<v t="karstenw.20250707224052.9"><vh>do_menu_STDMENUS</vh></v>
<v t="karstenw.20250707224052.10"><vh>do_menu_SELECTALL</vh></v>
<v t="karstenw.20250707224052.11"><vh>do_menu_COPY</vh></v>
<v t="karstenw.20250707224052.12"><vh>do_menu_LAYOUTMODE</vh></v>
<v t="karstenw.20250707224052.13"><vh>do_menu_BROWSEMODE</vh></v>
<v t="karstenw.20250707224052.14"><vh>iter_layouts</vh></v>
<v t="karstenw.20250707224052.15"><vh>iterwindows</vh></v>
<v t="karstenw.20250707224051.9"><vh>doExport</vh></v>
</v>
</v>
<v t="karstenw.20250707224722.1"><vh>@clean basetoolslib.py</vh>
<v t="karstenw.20250707224817.1"><vh>Declarations</vh></v>
<v t="karstenw.20250707224817.2"><vh>sortlist</vh></v>
<v t="karstenw.20250707224817.3"><vh>dotprinter</vh></v>
<v t="karstenw.20250707224817.4"><vh>makeunicode</vh></v>
<v t="karstenw.20250707224817.5"><vh>makeunicodelist</vh></v>
</v>
<v t="karstenw.20250707224749.1" a="E"><vh>@clean OutlineModelDelegate.py</vh>
<v t="karstenw.20250707224815.1"><vh>Declarations</vh></v>
<v t="karstenw.20250707224815.2"><vh>class OutlineModel</vh>
<v t="karstenw.20250707224815.3"><vh>initWithObject_</vh></v>
<v t="karstenw.20250707224815.4"><vh>setObject_</vh></v>
<v t="karstenw.20250707224815.5"><vh>outlineView_numberOfChildrenOfItem_</vh></v>
<v t="karstenw.20250707224815.6"><vh>outlineView_child_ofItem_</vh></v>
<v t="karstenw.20250707224815.7"><vh>outlineView_isItemExpandable_</vh></v>
<v t="karstenw.20250707224815.8"><vh>outlineView_objectValueForTableColumn_byItem_</vh></v>
<v t="karstenw.20250707224815.9"><vh>outlineView_setObjectValue_forTableColumn_byItem_</vh></v>
<v t="karstenw.20250707224815.10"><vh>outlineView_shouldEditTableColumn_item_</vh></v>
<v t="karstenw.20250707224815.11"><vh>outlineView_shouldSelectTableColumn_</vh></v>
<v t="karstenw.20250707224815.12"><vh>outlineView_shouldSelectItem_</vh></v>
<v t="karstenw.20250707224815.13"><vh>getSelectionItems</vh></v>
</v>
<v t="karstenw.20250707224815.14"><vh>class OutlineNode</vh>
<v t="karstenw.20250707224815.15"><vh>__new__</vh></v>
<v t="karstenw.20250707224815.16"><vh>__init__</vh></v>
<v t="karstenw.20250707224815.17"><vh>__repr__</vh></v>
<v t="karstenw.20250707224815.18"><vh>dealloc</vh></v>
<v t="karstenw.20250707224815.19"><vh>noOfChildren</vh></v>
<v t="karstenw.20250707224815.20"><vh>addChild_</vh></v>
<v t="karstenw.20250707224815.21"><vh>addChild_atIndex_</vh></v>
<v t="karstenw.20250707224815.22"><vh>childAtIndex_</vh></v>
<v t="karstenw.20250707224815.23"><vh>isExpandable</vh></v>
<v t="karstenw.20250707224815.24"><vh>isRoot</vh></v>
</v>
</v>
<v t="karstenw.20250707224804.1" a="E"><vh>@clean setup.py</vh>
<v t="karstenw.20250707224812.1"><vh>Declarations</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="karstenw.20250707223951.2"></t>
<t tx="karstenw.20250707224004.1">@language python
@tabwidth -4
@others

if __name__ == "__main__":
    PyObjCTools.AppHelper.runEventLoop()
</t>
<t tx="karstenw.20250707224051.1">
# -*- coding: utf-8 -*-

import sys, os
import _thread as thread


import re

import pdb
kwdbg = True

# pdb.set_trace()

import pprint
pp = pprint.pprint

import objc

import Foundation
import AppKit
NSWindowController = AppKit.NSWindowController

import PyObjCTools
import PyObjCTools.AppHelper

import OutlineModelDelegate
OutlineModel = OutlineModelDelegate.OutlineModel

import mactypes
import appscript

from basetoolslib import makeunicode

import fmpa10


g_lastfoundFMP = False


# py3 stuff
py3 = False
try:
    unicode('')
    punicode = unicode
    pstr = str
    punichr = unichr
except NameError:
    punicode = str
    pstr = bytes
    py3 = True
    punichr = chr
    long = int


</t>
<t tx="karstenw.20250707224051.2"># class defined in OutlineWindow.nib
class OutlineWindowController(NSWindowController):
    # the actual base class is NSWindowController

    cbPDF = objc.IBOutlet()
    cbXML = objc.IBOutlet()
    outlineView = objc.IBOutlet()

    @others

</t>
<t tx="karstenw.20250707224051.3">def __new__(cls, obj):
    return cls.alloc().initWithObject_(obj)

</t>
<t tx="karstenw.20250707224051.4">def initWithObject_(self, obj):
    self = self.initWithWindowNibName_("OutlineWindow")

    self.setWindowTitleForObject_(None)

    self.model = OutlineModel.alloc().initWithObject_(obj)

    self.outlineView.setDataSource_(self.model)
    self.outlineView.setDelegate_(self.model)
    self.outlineView.setTarget_(self)
    # self.outlineView.setDoubleAction_("doubleClick:")

    self.window().makeFirstResponder_(self.outlineView)
    self.cbPDF.setState_(True)
    self.cbXML.setState_(True)
    self.showWindow_(self)
    self.retain()
    return self

</t>
<t tx="karstenw.20250707224051.5">def windowWillClose_(self, notification):
    # see comment in self.initWithObject_()
    self.autorelease()

</t>
<t tx="karstenw.20250707224051.6">def setWindowTitleForObject_(self, obj):
    self.window().setTitle_( u"FMP-Layout-Exporter" )

</t>
<t tx="karstenw.20250707224051.7">def setObject_(self, obj):
    self.setWindowTitleForObject_(obj)
    self.model.setObject_(obj)
    self.outlineView.reloadData()

</t>
<t tx="karstenw.20250707224051.8">@objc.IBAction
def export_(self, sender):
    createPDF = self.cbPDF.state()
    createXML = self.cbXML.state()
    m = self.model
    ov = self.outlineView

    # pdb.set_trace()
    sel = ov.selectedRowIndexes()
    selectedItems = []
    n = 0
    if sel:
        n = sel.count()
    next = sel.firstIndex()
    selectedItems.append( ov.itemAtRow_(next) )

    for i in range(1, n):
        next = sel.indexGreaterThanIndex_(next)
        selectedItems.append( ov.itemAtRow_(next) )

    data = {}
    for item in selectedItems:
        n,d,w,p = item.name, item.dbref,item.winref,item.parent
        if w == u"window":
            continue
        if d not in data:
            data[d] = []
        data[d].append( (n,w) )
    
    fld = getFolderDialog()

    if fld:
        fld = fld[0]
        if 0:
            thread.start_new_thread(doExport, (data,
                                               fld,
                                               createPDF,
                                               createXML) )
        else:
            doExport(data, fld, createPDF, createXML)


</t>
<t tx="karstenw.20250707224051.9">def doExport(d, fld, createPDF, createXML ):
    #pool = Foundation.NSAutoreleasePool.alloc().init()
    # pdb.set_trace()
    fpa = get_filemaker( True )
    for k,v in d.items():
        # get winref
        print("k,v:", k,v)
        doc = fpa.documents[ k ]
        win = doc.windows[1]
        if os.path.exists( fld ):
            if v:
                iter_layouts( k, win, v, fld, createPDF, createXML )
    #del pool


</t>
<t tx="karstenw.20250707224052.1">class PythonBrowserAppDelegate(Foundation.NSObject):

    @others
</t>
<t tx="karstenw.20250707224052.10">def do_menu_SELECTALL():
    fpa = get_filemaker()
    ok = False
    try:
        fpa.menus[ u'Edit' ].menu_items[ u'Select All' ].do_menu(timeout=300)
        ok = True
    except appscript.reference.CommandError as v:
        try:
            fpa.menus[ u'Bearbeiten' ].menu_items[ u'Alles ausw\xe4hlen' ].do_menu(timeout=300)
            ok = True
        except appscript.reference.CommandError as w:
            # print( "ERROR:", v )
            pass
    return ok

</t>
<t tx="karstenw.20250707224052.11">def do_menu_COPY():
    fpa = get_filemaker()
    ok = False
    try:
        fpa.menus[ u'Edit' ].menu_items[  u'Copy' ].do_menu(timeout=600)
        ok = True
    except appscript.reference.CommandError as v:
        try:
            fpa.menus[ u'Bearbeiten' ].menu_items[  u'Kopieren' ].do_menu(timeout=600)
            ok = True
        except appscript.reference.CommandError as w:
            # print( "ERROR:", v )
            pass
    return ok

</t>
<t tx="karstenw.20250707224052.12">def do_menu_LAYOUTMODE():
    fpa = get_filemaker()
    ok = False
    try:
        fpa.menus[ u'View' ].menu_items[ u'Layout mode' ].do_menu(timeout=300)
        ok = True
    except appscript.reference.CommandError as v:
        try:
            fpa.menus[ u'Ansicht' ].menu_items[ u'Layoutmodus' ].do_menu(timeout=300)
            ok = True
        except appscript.reference.CommandError as w:
            # print( "ERROR:", v )
            pass
    return ok

</t>
<t tx="karstenw.20250707224052.13">def do_menu_BROWSEMODE():
    fpa = get_filemaker()
    ok = False
    try:
        fpa.menus[ u'View' ].menu_items[ u'Browse mode' ].do_menu()
        ok = True
    except appscript.reference.CommandError as v:
        try:
            fpa.menus[ u'Ansicht' ].menu_items[ u'Bl\xe4tternmodus' ].do_menu()
            ok = True
        except appscript.reference.CommandError as w:
            # print( "ERROR:", v )
            pass
    return ok

</t>
<t tx="karstenw.20250707224052.14">def iter_layouts( docname, winref, layolist, outfolder, doPDF, doXML ):
    fpa = get_filemaker( True )
    if not fpa:
        return False

    # we should be in Layout mode now
    # docname = winref.name()
    
    if docname.endswith( ')' ):
        winregex = re.compile("^(.+) \([-a-zA-Z0-9_%\.]+\)")
        m = winregex.match( docname )
        if m:
            docname = m.groups()[0]

    allLayoutnames = winref.layouts.name()

    winref.visible.set(True)
    winref.show()
    winref.go_to()

    # pdb.set_trace()
    idx = 0
    for layo in layolist:
        idx += 1
        
        name, id_ = layo
        
        layIndex = -1
        try:
            layIndex = allLayoutnames.index( name )
            # fmp layouts are 1-based
            layIndex += 1
        except Exception as err:
            print(  )
            print( "ERROR" )
            print( err )
        
        sid = str(id_).rjust(7,"0")
        s = u"Layout id=%s    %i/%i  -  '%s'  -  '%s'" % (sid, layIndex, len(allLayoutnames), docname, name)
        print( s )

        winref.layouts[ appscript.its.ID_==id_ ].go_to( timeout=600 )

        # select all
        ok = do_menu_SELECTALL()

        if ok:
            ok = do_menu_COPY()

            # pdb.set_trace()

            if ok:
                pboard = AppKit.NSPasteboard.generalPasteboard()
                if pboard:
                    pbtypes = pboard.types()

                    # make it "filenameable"
                    fname = docname.replace(".", "_")
                    fname = fname.replace("/", "_")
                    lidx = "0000" + str(layIndex)
                    lidx = lidx[-5:]
                    ln = name.replace(".", "_")
                    ln = ln.replace("/", "_")
                    ln = ln.replace(":", "_")

                    fname = fname + "_" + lidx + "_" + ln

                    fname = os.path.join(outfolder, fname)

                    for t in pbtypes:
                        data = pboard.dataForType_( t )
                        if type(ln) == str:
                            ln = makeunicode(ln, "utf-8")
                        #try:
                        #    # ln = ln.encode("utf-8")
                        #    # t = t.encode("utf-8")
                        #except Exception as v:
                        #    print( "\nERROR" )
                        #    print( v )
                        try:
                            if t in ( 'CorePasteboardFlavorType 0x584D4C4F',
                                      'CorePasteboardFlavorType 0x584D4C32' ):
                                if doXML:
                                    f = open ( fname + ".xml", 'wb')
                                    f.write( bytes(data) )
                                    f.close()
                            elif t == u'Apple PDF pasteboard type':
                                if doPDF:
                                    f = open ( fname + ".pdf", 'wb')
                                    f.write( bytes(data) )
                                    f.close()
                            elif t in ("public.jpeg",):
                                f = open ( fname + ".jpg", 'wb')
                                f.write( bytes(data) )
                                f.close()
                        except Exception as err:
                            print()
                            print(err)
                            pdb.set_trace()
                            print()
                                
                        del data
    winref.visible.set(False)

</t>
<t tx="karstenw.20250707224052.15">def iterwindows():
    dbs = get_fmp_docs()
    outpath = os.path.abspath("./")

    for db in dbs:
        db.show()
        w = db.windows[1]()
        w.show()
        w.go_to()
        name = w.name()

        # print( "Database: '%s'" % name.encode("utf-8") )

        # pdb.set_trace()

        # this one cannot be checked since we could be running under
        # std filemaker, which doesn't have this item
        ok = do_menu_STDMENUS()

        # this MUST be True
        ok = do_menu_LAYOUTMODE()

        layolist = w.layouts()
        # print( "layouts:", pp(layolist) )

        if ok:
            iter_layouts( w, layolist, outpath )

##################################
#
# FileMaker Section END
#
##################################



</t>
<t tx="karstenw.20250707224052.2">def applicationDidFinishLaunching_(self, notification):
    self.newBrowser_(self)

</t>
<t tx="karstenw.20250707224052.3">@objc.IBAction
def newBrowser_(self, sender):
    # pdb.set_trace()
    fpa = get_filemaker( True )
    if not fpa:
        return 
    data = getFMPData( fpa )
    #pdb.set_trace()
    OutlineWindowController( data )

</t>
<t tx="karstenw.20250707224052.4">def outlineViewSelectionDidChange_(self, sender):
    pass

</t>
<t tx="karstenw.20250707224052.5">def getFolderDialog():
    panel = AppKit.NSOpenPanel.openPanel()
    panel.setCanChooseFiles_(False)
    panel.setCanChooseDirectories_(True)
    panel.setAllowsMultipleSelection_(False)
    rval = panel.runModalForTypes_([])
    if rval != 0:
        return [makeunicode(t) for t in panel.filenames()]
    else:
        return False

##################################
#
# FileMaker Section START
#
##################################


</t>
<t tx="karstenw.20250707224052.6">def get_filemaker(bringtofront=True):
    """Create and return an application object for the default filemaker.

    If bringtofront it will be activated
    """
    global g_lastfoundFMP
    
    if g_lastfoundFMP:
        fpa = appscript.app( g_lastfoundFMP, terms=fmpa10)
        if fpa and bringtofront:
            fpa.activate()
        return fpa
    
    e = appscript.app("System Events.app")
    if not e.isrunning():
        e.activate()
    pl = e.application_processes[appscript.its.name.beginswith( 'FileMaker Pro' )].file.get()
    fpa = None
    pl.sort()
    pl.reverse()
    if 1:
        if pl:
            for p in pl:
                f = p.POSIX_path()
                if not f:
                    continue
                
                fpa = appscript.app( f, terms=fmpa10)
                if fpa.isrunning():
                    g_lastfoundFMP = f
                    if fpa and bringtofront:
                        fpa.activate()
                    return fpa
    if fpa and bringtofront:
        fpa.activate()
    return fpa


</t>
<t tx="karstenw.20250707224052.7">def get_fmp_docs():
    """Get open databases as documentrefs from filemaker.

    If db return databaserefs.
    """
    fpa = get_filemaker( True )
    if not fpa:
        return []
    return fpa.documents()


</t>
<t tx="karstenw.20250707224052.8">def getFMPData( fpa ):
    """Get open databases as documentrefs from filemaker.

    If db return databaserefs.
    """
    d = {}
    # pdb.set_trace()
    docs = fpa.documents()
    if docs:
        fpa.windows.visible.set(False)
        for doc in docs:
            doc.show()
            dname = doc.name()
            win = fpa.windows[ 1 ].name()
            if win.endswith( ')' ):
                winregex = re.compile("^(.+) \([-a-zA-Z0-9_%\.]+\)")
                m = winregex.match( win )
                if m:
                    win = m.groups()[0]
            winref = fpa.windows[ win ]
            w = doc.windows[1]()
            winref.visible.set(True)
            winref.show()
            winref.go_to()
            # name = makeunicode( doc.name() )
            name = makeunicode( win )

            do_menu_STDMENUS()

            # this MUST be True
            ok = do_menu_LAYOUTMODE()
            if ok:
                lnames = winref.layouts.name()
                lids = winref.layouts.ID_()
                d[dname] = []
                for l in zip(lids,lnames):
                    d[dname].append( (l[0],l[1]) )
            winref.visible.set(False)
    return d

</t>
<t tx="karstenw.20250707224052.9">def do_menu_STDMENUS():
    """Try to set Filemakere standard menus for frontmost document.
    This is needed to enter layout mode.

    return True on success
    """
    fpa = get_filemaker()
    ok = False
    try:
        fpa.menus[ u'Tools' ].menus[ u'Custom Menus' ].menu_items[ u'[Standard FileMaker Menus]' ].do_menu()
        ok = True
    except appscript.reference.CommandError as v:
        try:
            fpa.menus[ u'Werkzeuge' ].menus[ u'Angepasste Men\xfcs' ].menu_items[ u'[Standard-FileMaker-Men\xfcs]' ].do_menu()
            ok = True
        except appscript.reference.CommandError as w:
            pass
            # print( "ERROR:", v )
    return ok

</t>
<t tx="karstenw.20250707224152.1"></t>
<t tx="karstenw.20250707224722.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20250707224749.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20250707224804.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20250707224812.1">"""
Script for building the application.

Usage:
    python setup.py py2app -gx -O2
"""
import os

from distutils.core import setup
import py2app

appname = "FileMaker Layout Eporter"
appnameshort = "FMPLayoutexporter"
version = "V0.3.0"

copyright = u"Copyright 2009-2025 Karsten Wolf"

infostr = appname + u' ' + version + u' ' + copyright



setup(
    app=[{
        'script': "FMPLayoutexporter.py",

        'plist':{
            'CFBundleGetInfoString': infostr,
            'CFBundleIdentifier': 'org.kw.Layoutexporter',
            'CFBundleShortVersionString': version,
            'CFBundleDisplayName': appnameshort,
            'CFBundleName': appnameshort,
            'CFBundleSignature': 'KWLe',
            'LSHasLocalizedDisplayName': False,
            'NSAppleScriptEnabled': False,
            'NSHumanReadableCopyright': copyright}}],

    data_files=["English.lproj/MainMenu.nib",
                "English.lproj/OutlineWindow.nib",
                "Icon.icns"],
    options={
        'py2app':{
            'iconfile': "Icon.icns",
        },
    },
)
</t>
<t tx="karstenw.20250707224815.1">"""PythonBrowserModel.py -- module implementing the data model for PythonBrowser."""



import pdb
import pprint
pp = pprint.pprint
kwdbg = False
kwlog = True


import Foundation
NSObject = Foundation.NSObject

NSMutableArray = Foundation.NSMutableArray

NSNotFound = Foundation.NSNotFound
NSIndexSet = Foundation.NSIndexSet

NSNumber = Foundation.NSNumber


import AppKit
NSString = AppKit.NSString
NSMutableString = AppKit.NSMutableString


</t>
<t tx="karstenw.20250707224815.10">def outlineView_shouldEditTableColumn_item_(self, view, col, item):
    """Can item be edited?"""
    return False

</t>
<t tx="karstenw.20250707224815.11">def outlineView_shouldSelectTableColumn_(self, view, col):
    return False

</t>
<t tx="karstenw.20250707224815.12">def outlineView_shouldSelectItem_(self, view, item):
    return True

</t>
<t tx="karstenw.20250707224815.13">def getSelectionItems(self):
    if kwlog:
        print("getSelectionItems")
    """The actual nodes of the current selection are returned."""
    sel = self.selectedRowIndexes()
    result = []
    n = 0
    if sel:
        n = sel.count()
        if not n:
            return result
    next = sel.firstIndex()
    result.append( self.itemAtRow_(next) )

    for i in range(1, n):
        next = sel.indexGreaterThanIndex_(next)
        result.append( self.itemAtRow_(next) )
    return result


</t>
<t tx="karstenw.20250707224815.14">class OutlineNode(NSObject):

    """Wrapper class for items to be displayed in the outline view."""

    @others
</t>
<t tx="karstenw.20250707224815.15">def __new__(cls, *args, **kwargs):
    return cls.alloc().init()

</t>
<t tx="karstenw.20250707224815.16">def __init__(self, name, db, win, parent, rootNode):

    # this is outlinetype, not valueType
    self.name = name
    self.dbref = db
    self.winref = win
    self.parent = parent
    self.children = NSMutableArray.arrayWithCapacity_( 200 )
    self.retain()

</t>
<t tx="karstenw.20250707224815.17">def __repr__(self):
    return "&lt;OutlineNode(name='%s')" % (self.name,)

</t>
<t tx="karstenw.20250707224815.18">def dealloc(self):
    print( "OutlineNode.dealloc()" )
    self.children.release()

</t>
<t tx="karstenw.20250707224815.19">def noOfChildren(self):
    return self.children.count()

</t>
<t tx="karstenw.20250707224815.2">class OutlineModel(Foundation.NSObject):
    """This is a delegate as well as a data source for NSOutlineViews."""

    @others
</t>
<t tx="karstenw.20250707224815.20">def addChild_(self, child):
    if kwlog and 0:
        print( "OutlineNode.addChild_", child )
    if isinstance(child, OutlineNode):
        if child.parent != self:
            child.parent = self
        self.children.addObject_( child )

</t>
<t tx="karstenw.20250707224815.21">def addChild_atIndex_(self, child, index):
    if kwdbg:
        print( "addChild_atIndex_setParent", child )
    self.children.insertObject_atIndex_( child, index)
    child.parent = self

</t>
<t tx="karstenw.20250707224815.22">def childAtIndex_( self, index ):
    # delegeate child getter
    if index &lt;= self.children.count():
        return self.children.objectAtIndex_( index )
    return None

</t>
<t tx="karstenw.20250707224815.23">def isExpandable(self):
    return self.children.count() &gt; 0

</t>
<t tx="karstenw.20250707224815.24">def isRoot(self):
    return self.parent == None
</t>
<t tx="karstenw.20250707224815.3">def initWithObject_(self, obj):
    self = self.init()
    # pdb.set_trace()
    self.setObject_( None )
    for db in obj:
        # (name, db, win, parent, rootNode)
        dbnode = OutlineNode(db, db, "window", self.root, self.root)
        self.root.addChild_( dbnode )
        for layitem in obj[db]:
            id_,layname = layitem
            cnode = OutlineNode(layname, db, id_, dbnode, self.root)
            dbnode.addChild_( cnode )
    return self

</t>
<t tx="karstenw.20250707224815.4">def setObject_(self, obj):
    self.root = OutlineNode("root", "", "", None, None)

# NSOutlineViewDataSource  methods
</t>
<t tx="karstenw.20250707224815.5">def outlineView_numberOfChildrenOfItem_(self, view, item):
    if item is None:
        item = self.root
    return item.noOfChildren()

</t>
<t tx="karstenw.20250707224815.6">def outlineView_child_ofItem_(self, view, child, item):
    if not item:
        item = self.root
    return item.childAtIndex_( child )

</t>
<t tx="karstenw.20250707224815.7">def outlineView_isItemExpandable_(self, view, item):
    if item is None:
        item = self.root
    return item.isExpandable()

</t>
<t tx="karstenw.20250707224815.8">def outlineView_objectValueForTableColumn_byItem_(self, view, col, item):
    c = col.identifier()
    # TODO: COLUMNWORK
    if not item:
        item = self.root
    return item.name

</t>
<t tx="karstenw.20250707224815.9">def outlineView_setObjectValue_forTableColumn_byItem_(self, view, value, col, item):
    if not item:
        return
    if value != item.name:
        item.setName_(value)

</t>
<t tx="karstenw.20250707224817.1"># -*- coding: utf-8 -*-

from __future__ import print_function

import sys
import os

import struct

import unicodedata

import functools
cmp_to_key = functools.cmp_to_key

import pdb
import pprint
pp = pprint.pprint

# py3 stuff

py3 = False
try:
    unicode('')
    punicode = unicode
    pstr = str
    punichr = unichr
except NameError:
    punicode = str
    pstr = bytes
    py3 = True
    punichr = chr


__all__ = [
    "cmp_to_key", "sortlist", "dotprinter", "makeunicode", "makeunicodelist"
]


</t>
<t tx="karstenw.20250707224817.2">def sortlist(thelist, thecompare):
    if py3:
        sortkeyfunction = cmp_to_key( thecompare )
        thelist.sort( key=sortkeyfunction )
    else:
        thelist.sort( thecompare )


</t>
<t tx="karstenw.20250707224817.3">def dotprinter( count, scale=1000 ):
    dot = scale
    line = scale*100
    block = line * 5
    if count % dot == 0:
        sys.stdout.write(".")
        if count % line == 0:
            sys.stdout.write( "  " + str(count) )
            sys.stdout.write("\n")
            if count % block == 0:
                sys.stdout.write("\n")
        sys.stdout.flush()


</t>
<t tx="karstenw.20250707224817.4">def makeunicode(s, srcencoding="utf-8", normalizer="NFC"):
    if type(s) not in (punicode, pstr):
        s = str( s )
    if type(s) != punicode:
        s = punicode(s, srcencoding)
    s = unicodedata.normalize(normalizer, s)
    return s


</t>
<t tx="karstenw.20250707224817.5">def makeunicodelist(l, srcencoding="utf-8", normalizer="NFC"):
    result = []
    for item in l:
        s = makeunicode( item, srcencoding=srcencoding,  normalizer=normalizer)
        result.append( s )
    return result


</t>
</tnodes>
</leo_file>
